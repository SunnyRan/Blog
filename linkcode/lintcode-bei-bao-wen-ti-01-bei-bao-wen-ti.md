---
title: LintCode-背包问题（01背包问题）
date: '2016-03-10T20:39:10.000Z'
tags: CSDN迁移
---

# LintCode-背包问题（01背包问题）

版权声明：本文为博主原创文章，未经博主允许不得转载。 [https://blog.csdn.net/Sunny\_Ran/article/details/50849889](https://blog.csdn.net/Sunny_Ran/article/details/50849889)  
背包问题 II  
给出n个物品的体积A\[i\]和其价值V\[i\]，将他们装入一个大小为m的背包，最多能装入的总价值有多大？  
A\[i\], V\[i\], n, m均为整数。你不能将物品进行切分。你所挑选的物品总体积需要小于等于给定的m。

样例

对于物品体积\[2, 3, 5, 7\]和对应的价值\[1, 5, 2, 4\], 假设背包大小为10的话，最大能够装入的价值为9。

```text
//AC代码
public class Solution {
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A & V: Given n items with size A[i] and value V[i]
     * @return: The maximum value
     */
    public int backPackII(int m, int[] A, int V[]) {
        int len = A.length;
        int[] result=new int[m+1];
        for(int i = 0;i<len;i++){   
            for(int j = m; j>=A[i];j--){
                int temp = result[j-A[i]]+V[i];
                result[j]=Math.max(result[j],temp );
            }
        //  System.out.println(Arrays.toString(result));
        }
        return result[m];
    }
}
```

**基本思路**  
这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用子问题定义状态：即f\[i\]\[v\]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。 则其状态转移方程便是：  
![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdn.net/20160310203253733)  
这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将 它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略 （放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题 就转化为“前i-1件物品放入容量为v的背包中”，价值为f\[i-1\]\[v\]；如果放第i件物品，那么问题就转 化为“前i-1件物品放入剩下的容量为v-c\[i\]的背包中”，此时能获得的最大价值就是f\[i-1\]\[v-c\[i\]\]再 加上通过放入第i件物品获得的价值w\[i\]。

**优化空间复杂度**  
以上方法的时间和空间复杂度均为Θ\(V N\)，其中时间复杂度应该已经不能 再优化了，但空间复杂度却可以优化到Θ\(N\)1。 先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f\[i\]\[0..V\]的 所有值。那么，如果只用一个数组f\[0..V\]，能不能保证第i次循环结束后f\[v\]中表示的就是我们定 义的状态f\[i\]\[v\]呢？f\[i\]\[v\]是由f\[i-1\]\[v\]和f\[i-1\]\[v-c\[i\]\]两个子问题递推而来，能否保证在推f\[i\]\[v\]时（也 即在第i次主循环中推f\[v\]时）能够得到f\[i-1\]\[v\]和f\[i-1\]\[v-c\[i\]\]的值呢？事实上，这要求在每次主循环 中我们以v=V..0的顺序推f\[v\]，这样才能保证推f\[v\]时f\[v-c\[i\]\]保存的是状态f\[i-1\]\[v-c\[i\]\]的值。伪代码 如下：  
![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdn.net/20160310203408843)

其中的f\[v\] = max{f\[v\],f\[v−c\[i\]\]}一句恰就相当于我们的转移方程f\[i\]\[v\] = max{f\[i−1\]\[v\],f\[i− 1\]\[v−c\[i\]\]}，因为现在的f\[v-c\[i\]\]就相当于原来的f\[i−1\]\[v−c\[i\]\]。如果将v的循环顺序从上面的逆 序改成顺序的话，那么则成了f\[i\]\[v\]由f\[i\]\[v-c\[i\]\]推知，与本题意不符，但它却是另一个重要的背包 问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。

事实上，使用一维数组解01背包的程序在后面会被多次用到，所以这里抽象出一个处理一 件01背包中的物品过程，以后的代码中直接调用不加说明。 过程ZeroOnePack，表示处理一件01背包中的物品，两个参数cost、weight分别表明这件物品 的费用和价值。  
![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdn.net/20160310203447671)

注意这个过程里的处理与前面给出的伪代码有所不同。前面的示例程序写成v=V..0是为了 在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。而这里既然已经抽象成 看作黑箱的过程了，就可以加入优化。费用为cost的物品不会影响状态f\[0..cost-1\]，这是显然的。 有了这个过程以后，01背包问题的伪代码就可以这样写：

![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdn.net/20160310203519359)

**初始化的细节问题**  
我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。 有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别 这两种问法的实现方法是在初始化的时候有所不同。 如果是第一种问法，要求恰好装满背包，那么在初始化时除了f\[0\]为0其它f\[1..V\]均设为-∞， 这样就可以保证最终得到的f\[N\]是一种恰好装满背包的最优解。  
如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f\[0..V\]全部设 为0。  
为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合 法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好 装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是−∞了。如果 背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0， 所以初始时状态的值也就全部为0了。 这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初 始化进行讲解。

一个常数优化 前面的伪代码中有for v=V..1，可以将这个循环的下限进行改进。 由于只需要最后f\[v\]的值，倒推前一个物品，其实只要知道f\[v-w\[n\]\]即可。以此类推，对以 第j个背包，其实只需要知道到![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdn.net/20160310203711735)即可，即代码中的

![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdn.net/20160310203745735)

改为  
![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdn.net/20160310203822041)

这对于V比较大时是有用的。

**小结**  
01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想， 另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思 路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。

**扩展问题**

```text
//LintCode 背包问题
//在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]

/*如果有4个物品[2, 3, 5, 7]
如果背包的大小为11，可以选择[2, 3, 5]装入背包，最多可以装满10的空间。
如果背包的大小为12，可以选择[2, 3, 7]装入背包，最多可以装满12的空间。
函数需要返回最多能装满的空间大小。*/
public class Solution {
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    public int backPack(int m, int[] A) {
        int len = A.length;
        int[] result = new int[m + 1];
        for (int i = 0; i < len; i++) {
            for (int j = m; j >= A[i]; j--) {
                int temp = result[j - A[i]] + A[i];
                result[j] = Math.max(result[j], temp);
            }
        //  System.out.println(Arrays.toString(result));
        }
        return result[m];
    }
}
```

