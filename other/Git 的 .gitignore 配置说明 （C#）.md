---
title: Git 的 .gitignore 配置说明 （C#）
date: 2016-11-16 17:01:14
tags: CSDN迁移
---
  .gitignore 配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为我们的版本管理带来很大的便利，以下是个人对于配置 .gitignore 的一些心得。

 1、配置语法：

 以斜杠“/”开头表示目录；

 以星号“*”通配多个字符；

 以问号“?”通配单个字符

 以方括号“[]”包含单个字符的匹配列表；

 以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；

 此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；

 2、示例：

 （1）规则：fd1/*   
 说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；

 （2）规则：/fd1/*   
 说明：忽略根目录下的 /fd1/ 目录的全部内容；

 （3）规则：

 /*   
 !.gitignore   
 !/fw/bin/   
 !/fw/sf/

 说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；

 这里给出一个Visual Studio 的igitignor实例供大家参考。

 
```
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.

# User-specific files
*.suo
*.user
*.sln.docstates

# Build results

[Dd]ebug/
[Rr]elease/
x64/
build/
[Bb]in/
[Oo]bj/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

*_i.c
*_p.c
*.ilk
*.meta
*.obj
*.pch
*.pdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.log
*.scc

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opensdf
*.sdf
*.cachefile

# Visual Studio profiler
*.psess
*.vsp
*.vspx

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# NCrunch
*.ncrunch*
.*crunch*.local.xml

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.Publish.xml
*.pubxml

# NuGet Packages Directory
# Enable nuget packages restore when building
!packages/
packages/*
!packages/repositories.config

# Windows Azure Build Output
csx
*.build.csdef

# Windows Store app package directory
AppPackages/

# Others
sql/
*.Cache
ClientBin/
[Ss]tyle[Cc]op.*
~$*
*~
*.dbmdl
*.[Pp]ublish.xml
*.pfx
*.publishsettings

# RIA/Silverlight projects
Generated_Code/

#Visual Studio LightSwitch
_Pvt_Extensions/
GeneratedArtifacts/
ServiceConfiguration.cscfg
ModelManifest.xml
generated.parameters.xml
## TODO: Comment the next line if you want version controls the generated client .xap file
*.Client.xap

# Backup & report files from converting an old project file to a newer
# Visual Studio version. Backup files are not needed, because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm

# SQL Server files
App_Data/*.mdf
App_Data/*.ldf

# =========================
# Windows detritus
# =========================

# Windows image file caches
Thumbs.db
ehthumbs.db

# Folder config file
Desktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Mac crap
.DS_Store

# VisualStudioCode
.vscode
```
 GIT库中禁止追踪文件变化的两种方式

 在使用GIT库管理代码的时候，如果工程的编译配置不太合理，编译过程中生成的中间文件会和源代码混杂在一起，或者每次编译都会对某些文件都进行部分更新等。此类文件，往往会对GIT的add和commit操作造成麻烦，特别是当工程中大量存在此类文件时，在进行git add操作时，必需对需要更新的文件一个个单独add，这时真是费事费力，异常痛苦。当然，我们希望遇到每个工程都配置合理，避免上述问题。但是实际工作中，由于历史原因，或者是由于第三方代码的引入，上述问题似乎不可避免。   
 为了解决上述问题，GIT至少提供了两种方式来禁止追踪以上两类易变化但又不需要频繁check-in的文件，一种是大家熟悉的.gitignore文件，另一种是’git update-index’命令。下面详细描述两种方式的用法。

 使用.gitignore文件

 使用.gitignore的文件禁止GIT库追踪文件的方法比较简单，用起来很方便，网上的相关介绍也比较多。   
 比如说工程中有一个加入了一个第三方的源代码包，编译后生成的中间文件.o, .so, .a 文件均不需要添加到GIT库中进行管理，这时，只需要在第三方源代码包的顶级目录下加入一个.gitignore文件，填入如下过滤规则，即可忽略该目录下所有的.o, .so, .a文件：

 *.o   
 *.a   
 *.so   
 如果是一个比较大的工程，难以在短时间内确定工程中所有中间生成文件的具体位置，那么也有快速解决问题的办法。我采用的方式如下：

 Step 1: 取一个干净的初始GIT库；   
 Step 2: 编译整个工程；   
 Step 3: 在GIT库的根目录下，利用git clean -df命令查找出所有未被追踪的中间生成文件

 git clean -df > untracked_file.log   
 此时得到的untracked_file.log中包含了编译过程中生成目录和文件，并且还都没有被check-in进GIT库中。untracked_file.log的内容大概如下：

 ……   
 Removing project/develop/extra/target/lib/htb.so   
 Removing project/develop/mm_test/bin.macan/   
 ……   
 Step 4: 利用untracked_file.log 生成.gitignore（大家应该都能猜到该怎么做了)   
 编辑untracked_file.log, 查找所有的”Removing “字符串，替换为空，然后把文件改名为.gitignore即可。

 project/develop/extra/target/lib/htb.so   
 project/develop/mm_test/bin.macan/   
 step 5: 把生成的.gitignore放在GIT库的根目录下，并上传至GIT库。   
 如上操作便可以禁止GIT追踪编译过程中的中间生成目录和文件。

 利用’git update-index –assume-unchanged’ 命令

 当一个文件必需放进GIT库里，同时又不需要每次改动的时候都要在库中做更新的时候，.gitignore就派不上用场了。你可能疑惑，怎么会有这样的文件呢？   
 举个例子，比如说我的工程中有一个buildtime.h, 每次make的时候，makefile中会自动的调用脚本获取当前系统时间，并更新buildtime.h中关于BUILD_TIME的宏定义。这个文件必需放在库里，否则编译的时候会告诉你找不到头文件；同时，这个文件每次编译都会更新，但是根本不需要提交更新.(历史遗留代码)。   
 再举个例子，比如说，工程里包含了很多第三方的包，开发时从来不需要改动第三方的源代码，但是每次编译，第三方的源文件或多或少都会发生一些变化。这种情况其实比较常见，原因也比较多，但总之，第三方代码在编译的过程中发生的改动完全不需要被提交到库里。   
 以上两种情形，.gitignore是没法用的，却可以通过如下命令告诉本地GIT库，不必对指定的文件进行追踪：

 git update-index –assume-unchanged project/buildtime.h   
 如果接手一个比较大的工程，里边有巨多此类的文件，该怎么处理，一个个都找出来吗？不用担心，我采用的方法如下:

 step 1: 取一个干净的初始GIT库；   
 step 2: 编译整个工程；   
 step 3: 在GIT库的根目录下，利用git clean -df命令，清理掉所有的中间生成文件和目录（参考.gitignore技巧中的step 3);   
 step 4: 利用git status命令，获取modified文件列表；

 git status > modified_file.log   
 modified_file.log的内容，通常如下:

 
```
......
#        modified:    project/buildtime.h
......
```
 step 5: 编辑modified_file.log，生成disable_track.sh脚本。同样是对文件是查找，替换操作，最后生成如下的.sh脚本

 
```
#!/bin/bash
git update-index --assume-unchanged project/buildtime.h
......
```
 通常，我还会再生成一个enable_track.sh脚本，作为disable_track.sh的反向操作，以备不时之需：

 
```
#!/bin/bash
git update-index --no-assume-unchanged project/buildtime.h
......
```
 step 6: 在本地库中执行disable_track.sh脚本, 即可禁止本地库对指定的文件进行追踪。如果需要忽略文件巨多，这步操作耗时会比较久，好在只要执行一次就可以了。   
 step 7: 把刚生成的脚本上传到GIT库，通知团队其它成员执行。’git update-index‘ 可不比.gitignore， 这个命令仅对本地库生效，所以需要上传到GIT库，让团队其它开发人员自己在本地库下执行脚本。

 总结

 我现在使用的GIT工程，每次编译后，大量存在上述两类文件。每次执行git add需要找到自己改动过的文件一个一个添加，实在是无法忍受，就花了点时间在工程里做了上述的处理，效果出奇的好，不但git add可以随便用了，而且，由于大量变化的文件不需要跟踪了，GIT add, commit的操作速度也提升了不少。

   
  